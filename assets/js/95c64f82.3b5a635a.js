"use strict";(self.webpackChunkifn_survey_handbook=self.webpackChunkifn_survey_handbook||[]).push([[5496],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>f});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var p=r.createContext({}),l=function(e){var n=r.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},u=function(e){var n=l(e.components);return r.createElement(p.Provider,{value:n},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,p=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),m=l(t),d=a,f=m["".concat(p,".").concat(d)]||m[d]||c[d]||o;return t?r.createElement(f,s(s({ref:n},u),{},{components:t})):r.createElement(f,s({ref:n},u))}));function f(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,s=new Array(o);s[0]=d;var i={};for(var p in n)hasOwnProperty.call(n,p)&&(i[p]=n[p]);i.originalType=e,i[m]="string"==typeof e?e:a,s[1]=i;for(var l=2;l<o;l++)s[l]=t[l];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},2542:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>s,default:()=>c,frontMatter:()=>o,metadata:()=>i,toc:()=>l});var r=t(7462),a=(t(7294),t(3905));const o={sidebar_label:"Expressions",sidebar_class_name:"green"},s="Expressions",i={unversionedId:"survey-handbook/general/expressions",id:"survey-handbook/general/expressions",title:"Expressions",description:"Expression is a general concept used in several places of the Influenzanet Survey System.",source:"@site/docs/survey-handbook/general/02-expressions.md",sourceDirName:"survey-handbook/general",slug:"/survey-handbook/general/expressions",permalink:"/docs/survey-handbook/general/expressions",draft:!1,editUrl:"https://github.com/influenzanet/survey-handbook/docs/survey-handbook/general/02-expressions.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_label:"Expressions",sidebar_class_name:"green"},sidebar:"surveySidebar",previous:{title:"General Concepts",permalink:"/docs/survey-handbook/general/concepts"},next:{title:"Introduction",permalink:"/docs/survey-handbook/survey-engine/"}},p={},l=[{value:"Expression",id:"expression",level:2},{value:"ExpressionArg",id:"expressionarg",level:2},{value:"Expression definition notation",id:"expression-definition-notation",level:2},{value:"Common Argument types",id:"common-argument-types",level:2}],u={toc:l},m="wrapper";function c(e){let{components:n,...t}=e;return(0,a.kt)(m,(0,r.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"expressions"},"Expressions"),(0,a.kt)("p",null,"Expression is a ",(0,a.kt)("a",{parentName:"p",href:"./concepts"},"general concept")," used in several places of the Influenzanet Survey System.\nExpressions provide dynamic property evaluation for the survey logic and logic in study rules."),(0,a.kt)("p",null,"They are represented as a hierarchical data structure (an expression can contain and use the results of nested expressions as arguments)\nin two forms in the survey System : ",(0,a.kt)("inlineCode",{parentName:"p"},"Expression")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"ExpressionArg"),"."),(0,a.kt)("h2",{id:"expression"},"Expression"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Expression")," represents an operation to be evaluated later by the ",(0,a.kt)("a",{parentName:"p",href:"../survey-engine/"},"Survey Engine")," or ",(0,a.kt)("a",{parentName:"p",href:"../study-service/"},"Study Service"),") to produce a value (often boolean but not always) or a side effect (an action like sending a message or assigning a survey)."),(0,a.kt)("p",null,"An ",(0,a.kt)("strong",{parentName:"p"},"Expression")," is a simple data structure containing a ",(0,a.kt)("inlineCode",{parentName:"p"},"name")," field with the name of the function to call and a ",(0,a.kt)("inlineCode",{parentName:"p"},"data")," field containing the list of parameters of the call using an ",(0,a.kt)("inlineCode",{parentName:"p"},"ExpressionArg")," (each entry of the arguments list must be an ExpressionArg)."),(0,a.kt)("h2",{id:"expressionarg"},"ExpressionArg"),(0,a.kt)("p",null,"An ",(0,a.kt)("strong",{parentName:"p"},"ExpressionArg")," is a data structure used to define an argument value of an Expression (each entry of the ",(0,a.kt)("inlineCode",{parentName:"p"},"data")," field of an expression is an ",(0,a.kt)("em",{parentName:"p"},"ExpressionArg"),"). It can contain a expression or a literal value.\n",(0,a.kt)("em",{parentName:"p"},"ExpressionArg")," are used when the expected value can be a fixed value (string or numeric) or an ",(0,a.kt)("em",{parentName:"p"},"Expression")," like in ",(0,a.kt)("a",{parentName:"p",href:"../survey-engine/components/overview"},"Survey Item Components properties"),"."),(0,a.kt)("p",null,"ExpressionArg definition is (typescript notation is used, '?' after the name means it's an optional value)"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"{\n    dtype?: 'exp' | 'num' | 'str'\n    str?: string\n    num?: number\n    exp?: Expression\n}\n\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"dtype")," field indicates what kind of value the ExpressionArg contains, if ",(0,a.kt)("inlineCode",{parentName:"p"},"dtype")," is missing then the ExpressionArg must have a string value in ",(0,a.kt)("inlineCode",{parentName:"p"},"str")," field."),(0,a.kt)("p",null,"Examples:"),(0,a.kt)("p",null,"A string :"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "str":"This is a string based ExpressionArg"\n}\n')),(0,a.kt)("p",null,"Note: the ",(0,a.kt)("inlineCode",{parentName:"p"},"dtype")," field is not necessary in case of string value."),(0,a.kt)("p",null,"A numeric value"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "dtype":"num",\n    "num":12345\n}\n')),(0,a.kt)("p",null,"An expression for the logical operation '1 AND 1', the numeric value 1 act for boolean value ",(0,a.kt)("inlineCode",{parentName:"p"},"true"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "dtype":"exp",\n    "exp": {\n        "name": "and",\n        "data":[\n            {"dtype":"num", "num": 1},\n            {"dtype":"num", "num": 1}\n        ]\n    }\n}\n')),(0,a.kt)("h2",{id:"expression-definition-notation"},"Expression definition notation"),(0,a.kt)("p",null,"To make it easier to read the expressions definition we will use a function signature representation\n",(0,a.kt)("inlineCode",{parentName:"p"},"function_name( argument1, argument2, ?optional):return_type")," equivalent of the Expression data structure:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},"{\n   name: 'function_name',\n   data: [\n       argument1,\n       argument2\n   ]\n}\n\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"return_type")," can eventually inform about the kind of value returned by the expression\nAn argument prefixed by '?' mark is optional"),(0,a.kt)("h2",{id:"common-argument-types"},"Common Argument types"),(0,a.kt)("p",null,"Several types of arguments can be provided"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"item_key"),": the key path of the item of the survey (i.e. the fully qualified name of the item, from the survey root)"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"rg_key")," : The response component path in the item from the root component (the full path of the response from the root). It always starts with the 'rg.' because the response Group component must have the 'rg' key.")),(0,a.kt)("p",null,"For example,"),(0,a.kt)("p",null,"If you have an Item named 'Q1', in a survey named 'intake' (without question group), item_key will be 'intake.Q1'\nIf this Q1 is a single choice question (only one response component), ",(0,a.kt)("inlineCode",{parentName:"p"},"rg_key")," will be 'rg.scg', for a multiple Choice 'rg.mcg'"),(0,a.kt)("p",null,"These path-like identifiers are described in the ",(0,a.kt)("a",{parentName:"p",href:"../survey-engine/structure"},"Survey Structure")," page."))}c.isMDXComponent=!0}}]);